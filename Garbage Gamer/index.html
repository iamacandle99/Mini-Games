<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wasteland Jump - 3D First Person</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #d4d4d4;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border: 2px solid #555;
            cursor: pointer;
            z-index: 10;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0f0;
            font-size: 28px;
            text-shadow: 2px 2px #000;
            pointer-events: none;
            font-weight: bold;
        }
        h1 { color: #f00; margin-top: 0; letter-spacing: 5px; }
        .hint { font-size: 0.8em; color: #888; margin-top: 20px; }
        #game-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 100; flex-direction: column; }
        #game-overlay .msg { color: #0f0; font-size: 1.5em; text-align: center; white-space: pre-line; margin-bottom: 20px; text-shadow: 0 0 10px #0f0; }
        #game-overlay button { background: #333; color: #0f0; border: 2px solid #0f0; padding: 12px 30px; font-size: 1em; cursor: pointer; font-family: inherit; }
        #game-overlay button:hover { background: #0f0; color: #000; }
    </style>
</head>
<body>
    <div id="instructions">
        <h1>WASTELAND JUMP</h1>
        <p>DO NOT TOUCH THE TOXIC WASTE BELOW.</p>
        <p>Jump from platform to platform to survive.</p>
        <p style="font-weight: bold; font-size: 1.2em; color: #fff;">(CLICK TO START)</p>
        <div class="hint">
            W, A, S, D = MOVE<br>
            SPACE = JUMP<br>
            ESC = PAUSE
        </div>
    </div>
    <div id="crosshair"></div>
    <div id="ui">Score: 0</div>
    <div id="game-overlay"><div class="msg"></div><button>CONTINUE</button></div>

    <!-- Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.fog = new THREE.FogExp2(0x1a1a1a, 0.04);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 2; // Initial height above starting platform

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, document.body);
        const instructions = document.getElementById('instructions');
        const uiScore = document.getElementById('ui');

        function showGameOverlay(text, callback) {
            const overlay = document.getElementById('game-overlay');
            overlay.querySelector('.msg').textContent = text;
            overlay.style.display = 'flex';
            const btn = overlay.querySelector('button');
            btn.onclick = () => { overlay.style.display = 'none'; if (callback) callback(); };
        }

        instructions.addEventListener('click', () => {
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            instructions.style.display = 'none';
        });

        controls.addEventListener('unlock', () => {
            instructions.style.display = 'block';
        });

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffaa66, 1.5); // Sunset / Smoggy feel
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // --- Game Variables ---
        let score = 0;
        let level = 1;
        const PLATFORMS_PER_LEVEL = 15;
        let platformsInCurrentLevel = 0;
        let canJump = false;
        let jumpCount = 0;
        const MAX_JUMPS = 2;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const moveKeys = { forward: false, backward: false, left: false, right: false };

        const PLATFORM_SIZE = 5;
        const platforms = [];
        const decorations = [];
        const PLAYER_HEIGHT = 2;

        // --- Environment Creation ---
        function createGarbageMound(x, z) {
            const group = new THREE.Group();
            const layers = 4;
            for (let i = 0; i < layers; i++) {
                const radius = (layers - i) * 2;
                const geo = new THREE.SphereGeometry(radius, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                const mat = new THREE.MeshPhongMaterial({ 
                    color: i % 2 === 0 ? 0x3d3d2e : 0x2e2e1f,
                    flatShading: true
                });
                const mound = new THREE.Mesh(geo, mat);
                mound.position.y = -8 + (i * 1.5);
                mound.scale.y = 0.6;
                group.add(mound);
            }
            group.position.set(x, 0, z);
            scene.add(group);
            decorations.push(group);
        }

        function createDumpsterTruck(x, y, z, rotation) {
            const group = new THREE.Group();
            
            // Body
            const bodyGeo = new THREE.BoxGeometry(4, 3, 8);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0x224422 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            group.add(body);

            // Cab
            const cabGeo = new THREE.BoxGeometry(3.8, 2.5, 3);
            const cabMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const cab = new THREE.Mesh(cabGeo, cabMat);
            cab.position.set(0, -0.25, 5.5);
            cab.castShadow = true;
            group.add(cab);

            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 12);
            const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            const wheelPositions = [
                [-2, -1.5, 4], [2, -1.5, 4],
                [-2, -1.5, -3], [2, -1.5, -3]
            ];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                group.add(wheel);
            });

            group.position.set(x, y + 1.5, z);
            group.rotation.y = rotation;
            scene.add(group);
            decorations.push(group);
        }

        function createEndGate(x, y, z) {
            const group = new THREE.Group();
            const pillarGeo = new THREE.BoxGeometry(1, 10, 1);
            const pillarMat = new THREE.MeshPhongMaterial({ color: 0xffcc00 }); // Caution yellow
            
            const leftPillar = new THREE.Mesh(pillarGeo, pillarMat);
            leftPillar.position.set(-4, 5, 0);
            group.add(leftPillar);

            const rightPillar = new THREE.Mesh(pillarGeo, pillarMat);
            rightPillar.position.set(4, 5, 0);
            group.add(rightPillar);

            const topPillar = new THREE.Mesh(new THREE.BoxGeometry(9, 1, 1), pillarMat);
            topPillar.position.set(0, 10, 0);
            group.add(topPillar);

            // Glowing field
            const fieldGeo = new THREE.PlaneGeometry(7, 9);
            const fieldMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const field = new THREE.Mesh(fieldGeo, fieldMat);
            field.position.set(0, 5, 0);
            group.add(field);

            group.position.set(x, y, z);
            group.userData.isEndGate = true;
            scene.add(group);
            platforms.push(group); // Add to platforms for intersection check
            return group;
        }

        // Ground (Toxic Waste / Garbage Pile)
        const groundGeo = new THREE.PlaneGeometry(2000, 2000);
        // Use a displacement-like look with color
        const groundMat = new THREE.MeshPhongMaterial({ 
            color: 0x0a150a,
            emissive: 0x051a05,
            shininess: 10
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -8; 
        ground.receiveShadow = true;
        scene.add(ground);

        // Scattered Garbage Blocks
        for (let i = 0; i < 400; i++) {
            const size = Math.random() * 3 + 1;
            const geo = new THREE.BoxGeometry(size, size, size);
            const mat = new THREE.MeshPhongMaterial({ 
                color: Math.random() > 0.5 ? 0x333333 : 0x2d3a2d 
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(
                (Math.random() - 0.5) * 500,
                -8 + size/2 - 0.5,
                (Math.random() - 0.5) * 500
            );
            mesh.rotation.set(Math.random(), Math.random(), Math.random());
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
        }

        function createPlatform(x, y, z, index) {
            const height = 0.8;
            const geo = new THREE.BoxGeometry(PLATFORM_SIZE, height, PLATFORM_SIZE);
            const mat = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.index = index;
            scene.add(mesh);
            platforms.push(mesh);

            // Platform Support Pillar (stretching down into garbage)
            const pillarGeo = new THREE.BoxGeometry(PLATFORM_SIZE * 0.8, 20, PLATFORM_SIZE * 0.8);
            const pillarMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const pillar = new THREE.Mesh(pillarGeo, pillarMat);
            pillar.position.y = -10.4;
            mesh.add(pillar);
            
            // Red glowing light for next target
            if (index > 0) {
                const lightGeo = new THREE.SphereGeometry(0.2, 8, 8);
                const lightMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const light = new THREE.Mesh(lightGeo, lightMat);
                light.position.set(0, 0.5, 0);
                mesh.add(light);
            }
        }

        // Generate initial platforms
        let nextX = 0;
        let nextZ = 0;
        let nextY = 0;
        let platformCounter = 1;

        function addRandomPlatform() {
            if (platformsInCurrentLevel >= PLATFORMS_PER_LEVEL) {
                // Add End Gate
                const dist = 15;
                const angle = (Math.random() - 0.5) * Math.PI * 0.5;
                nextX += Math.sin(angle) * dist;
                nextZ -= Math.cos(angle) * dist;
                createEndGate(nextX, nextY, nextZ);
                platformsInCurrentLevel = 0; // Reset for next level
                return;
            }

            // Difficulty increases with level
            const baseDist = 12 + (level * 1.5);
            const dist = baseDist + Math.random() * 6;
            const angle = (Math.random() - 0.5) * Math.PI * (0.7 + level * 0.05);
            
            nextX += Math.sin(angle) * dist;
            nextZ -= Math.cos(angle) * dist;
            // Platforms gradually get higher or lower, steeper with level
            nextY = Math.max(-4, Math.min(10, nextY + (Math.random() - 0.5) * (3 + level)));

            createPlatform(nextX, nextY, nextZ, platformCounter++);
            platformsInCurrentLevel++;

            // Randomly add decorations near platforms
            if (Math.random() > 0.7) createGarbageMound(nextX + (Math.random() - 0.5) * 20, nextZ + (Math.random() - 0.5) * 20);
            if (Math.random() > 0.8) createDumpsterTruck(nextX + (Math.random() - 0.5) * 30, -8, nextZ + (Math.random() - 0.5) * 30, Math.random() * Math.PI);
        }

        // Initialize First Level
        setupLevel();

        // Update UI with level
        function updateUI() {
            uiScore.innerHTML = `Level: ${level}<br>Score: ${score}`;
        }
        updateUI();

        // --- Controls Handling ---
        const onKeyDown = (event) => {
            switch (event.code) {
                case 'KeyW': moveKeys.forward = true; break;
                case 'KeyA': moveKeys.left = true; break;
                case 'KeyS': moveKeys.backward = true; break;
                case 'KeyD': moveKeys.right = true; break;
                case 'Space':
                    if (canJump === true || jumpCount < MAX_JUMPS) {
                        if (jumpCount === 0) {
                            velocity.y += 24; // Initial jump
                        } else {
                            velocity.y = 20; // Double jump (resets upward momentum)
                        }
                        jumpCount++;
                        canJump = false;
                    }
                    break;
            }
        };

        const onKeyUp = (event) => {
            switch (event.code) {
                case 'KeyW': moveKeys.forward = false; break;
                case 'KeyA': moveKeys.left = false; break;
                case 'KeyS': moveKeys.backward = false; break;
                case 'KeyD': moveKeys.right = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // Reset keys on blur to prevent "ghost" movement
        window.addEventListener('blur', () => {
            moveKeys.forward = false;
            moveKeys.backward = false;
            moveKeys.left = false;
            moveKeys.right = false;
        });

        // --- Animation Loop ---
        let prevTime = performance.now();
        const playerBox = new THREE.Box3();
        const platformBox = new THREE.Box3();

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); // Cap delta to prevent huge jumps

            if (controls.isLocked) {
                // Physics/Movement dampening
                velocity.x -= velocity.x * 12.0 * delta; // Further increased friction (was 10.0)
                velocity.z -= velocity.z * 12.0 * delta; // Further increased friction
                velocity.y -= 9.8 * 6.5 * delta; // Gravity

                direction.z = Number(moveKeys.forward) - Number(moveKeys.backward);
                direction.x = Number(moveKeys.right) - Number(moveKeys.left);
                
                // Only normalize if there is movement to avoid NaN values
                if (moveKeys.forward || moveKeys.backward || moveKeys.left || moveKeys.right) {
                    direction.normalize();
                }

                if (moveKeys.forward || moveKeys.backward) velocity.z -= direction.z * 175.0 * delta; // Set to 175.0
                if (moveKeys.left || moveKeys.right) velocity.x -= direction.x * 175.0 * delta; // Set to 175.0

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                camera.position.y += (velocity.y * delta);

                // Collision Detection (Platforms)
                // We define the player's collision volume
                const feetY = camera.position.y - PLAYER_HEIGHT;
                playerBox.setFromCenterAndSize(
                    new THREE.Vector3(camera.position.x, camera.position.y - 1, camera.position.z),
                    new THREE.Vector3(1, 2, 1)
                );

                let standing = false;
                for (let p of platforms) {
                    platformBox.setFromObject(p);
                    if (playerBox.intersectsBox(platformBox)) {
                        // Immediate check for end gate intersection
                        if (p.userData.isEndGate) {
                            nextLevel();
                            return; // Exit loop and frame early
                        }

                        // Normal platform standing logic
                        if (velocity.y <= 0 && feetY >= p.position.y - 0.5) {
                            camera.position.y = p.position.y + PLAYER_HEIGHT;
                            velocity.y = 0;
                            canJump = true;
                            jumpCount = 0; // Reset double jump
                            standing = true;
                            
                            // Score tracking
                            if (p.userData.index > score) {
                                score = p.userData.index;
                                updateUI();
                                // Change platform color to show visited
                                p.material.color.setHex(0x226622);
                            }
                            break; 
                        }
                    }
                }

                // Death check
                if (camera.position.y < -7) {
                    resetGame();
                }
            }

            renderer.render(scene, camera);
            prevTime = time;
        }

        function nextLevel() {
            level++;
            showGameOverlay(`LEVEL ${level-1} COMPLETE!\nAdvancing to Level ${level}...\nDistance and height variation will increase!`, () => setupLevel());
        }

        function setupLevel() {
            // Clean up old platforms and decorations
            platforms.forEach(p => scene.remove(p));
            platforms.length = 0;
            decorations.forEach(d => scene.remove(d));
            decorations.length = 0;

            // Reset generation variables
            nextX = 0;
            nextZ = 0;
            nextY = 0;
            platformsInCurrentLevel = 0;
            
            // Set platformCounter to start after the previous level's platforms
            platformCounter = (level - 1) * PLATFORMS_PER_LEVEL + 1;

            // Generate first platform (index is the base score for this level)
            createPlatform(0, 0, 0, (level - 1) * PLATFORMS_PER_LEVEL);
            
            // Generate the rest of the level
            for (let i = 0; i < PLATFORMS_PER_LEVEL + 1; i++) {
                addRandomPlatform();
            }

            // Reset player position and state
            camera.position.set(0, PLAYER_HEIGHT + 0.5, 0);
            velocity.set(0, 0, 0);
            updateUI();
        }

        function resetGame() {
            showGameOverlay("FATAL EXPOSURE: YOU DIED!\nRestarting Level " + level + "\nTotal Score: " + score, () => {
                score = (level - 1) * PLATFORMS_PER_LEVEL;
                setupLevel();
                moveKeys.forward = false;
                moveKeys.backward = false;
                moveKeys.left = false;
                moveKeys.right = false;
                controls.unlock();
            });
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
